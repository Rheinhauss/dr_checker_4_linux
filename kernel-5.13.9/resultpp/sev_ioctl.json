{"all_contexts":[
{"num_warnings": 3,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}],
"warnings":[{"warn_data": {"at_line": 826, "warn_str": "Trying to use a global variable without locking.", "at": "if (!psp_master || !psp_master->sev_data)", "inst_trace": [{"instr_func": "sev_ioctl", "instr_loc": -1, "instr": "  %4 = alloca i8*, align 8"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "GlobalVariableRaceDetector says:", "at_func": "sev_ioctl"}, "warn_no": 1},
{"warn_data": {"at_line": 832, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&input, argp, sizeof(struct sev_issue_cmd)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl"}, "warn_no": 2},
{"warn_data": {"at_line": 875, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user(argp, &input, sizeof(struct sev_issue_cmd)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl"}, "warn_no": 3}]},
{"num_warnings": 8,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 868, "file": "drivers/crypto/ccp/sev-dev.c", "instr": "ret = sev_ioctl_do_get_id2(&input);"}],
"warnings":[{"warn_data": {"at_line": 645, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 1},
{"warn_data": {"at_line": 651, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "id_blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 645, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 2},
{"warn_data": {"at_line": 651, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "id_blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 645, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 3},
{"warn_data": {"at_line": 651, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "id_blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 645, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 4},
{"warn_data": {"at_line": 651, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "id_blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 645, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 5},
{"warn_data": {"at_line": 651, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "id_blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 645, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_get_id2", "instr_loc": 651, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "id_blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 6},
{"warn_data": {"at_line": 662, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "ret = __sev_do_cmd_locked(SEV_CMD_GET_ID, &data, &argp->error);", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 7},
{"warn_data": {"at_line": 676, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user(input_address, id_blob, data.len)) {", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_get_id2"}, "warn_no": 8}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 865, "file": "drivers/crypto/ccp/sev-dev.c", "instr": "ret = sev_ioctl_do_get_id(&input);"}],
"warnings":[{"warn_data": {"at_line": 719, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user((void __user *)argp->data, id_blob, data->len))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_get_id"}, "warn_no": 1}]},
{"num_warnings": 14,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 861, "file": "drivers/crypto/ccp/sev-dev.c", "instr": "ret = sev_ioctl_do_pdh_export(&input, writable);"}],
"warnings":[{"warn_data": {"at_line": 748, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 1},
{"warn_data": {"at_line": 770, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 2},
{"warn_data": {"at_line": 770, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 3},
{"warn_data": {"at_line": 770, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 4},
{"warn_data": {"at_line": 770, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 5},
{"warn_data": {"at_line": 770, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 770, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "pdh_blob = kmalloc(input.pdh_cert_len, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 6},
{"warn_data": {"at_line": 774, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "data.pdh_cert_address = __psp_pa(pdh_blob);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 7},
{"warn_data": {"at_line": 774, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "data.pdh_cert_address = __psp_pa(pdh_blob);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 8},
{"warn_data": {"at_line": 774, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "data.pdh_cert_address = __psp_pa(pdh_blob);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 9},
{"warn_data": {"at_line": 774, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "data.pdh_cert_address = __psp_pa(pdh_blob);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 10},
{"warn_data": {"at_line": 774, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "data.pdh_cert_address = __psp_pa(pdh_blob);", "inst_trace": [{"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 748, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 777, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "cert_blob = kmalloc(input.cert_chain_len, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}, {"instr_func": "sev_ioctl_do_pdh_export", "instr_loc": 774, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "data.pdh_cert_address = __psp_pa(pdh_blob);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 11},
{"warn_data": {"at_line": 786, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "cmd:", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 12},
{"warn_data": {"at_line": 799, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user(input_pdh_cert_address,", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 13},
{"warn_data": {"at_line": 807, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user(input_cert_chain_address,", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pdh_export"}, "warn_no": 14}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 858, "file": "drivers/crypto/ccp/sev-dev.c", "instr": "ret = sev_ioctl_do_pek_import(&input, writable);"}],
"warnings":[{"warn_data": {"at_line": 595, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pek_import"}, "warn_no": 1}]},
{"num_warnings": 8,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 855, "file": "drivers/crypto/ccp/sev-dev.c", "instr": "ret = sev_ioctl_do_pek_csr(&input, writable);"}],
"warnings":[{"warn_data": {"at_line": 413, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 1},
{"warn_data": {"at_line": 427, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 413, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 2},
{"warn_data": {"at_line": 427, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 413, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 3},
{"warn_data": {"at_line": 427, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 413, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 4},
{"warn_data": {"at_line": 427, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 413, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 5},
{"warn_data": {"at_line": 427, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "blob = kmalloc(input.length, GFP_KERNEL);", "inst_trace": [{"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 413, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "if (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}, {"instr_func": "sev_ioctl_do_pek_csr", "instr_loc": 427, "instr_file": "drivers/crypto/ccp/sev-dev.c", "instr": "blob = kmalloc(input.length, GFP_KERNEL);"}], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "IntegerOverflowDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 6},
{"warn_data": {"at_line": 441, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "ret = __sev_do_cmd_locked(SEV_CMD_PEK_CSR, &data, &argp->error);", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 7},
{"warn_data": {"at_line": 452, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user(input_address, blob, input.length))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_pek_csr"}, "warn_no": 8}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 846, "file": "drivers/crypto/ccp/sev-dev.c", "instr": "ret = sev_ioctl_do_platform_status(&input);"}],
"warnings":[{"warn_data": {"at_line": 378, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_to_user((void __user *)argp->data, &data, sizeof(data)))", "inst_trace": [], "at_file": "drivers/crypto/ccp/sev-dev.c", "by": "TaintedSizeDetector says:", "at_func": "sev_ioctl_do_platform_status"}, "warn_no": 1}]}]}