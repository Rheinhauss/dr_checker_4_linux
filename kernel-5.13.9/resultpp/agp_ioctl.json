{"all_contexts":[
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 1018, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_unbind_wrap(curr_priv, (void __user *) arg);"}],
"warnings":[{"warn_data": {"at_line": 936, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&unbind, arg, sizeof(struct agp_unbind)))", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_unbind_wrap"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 1018, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_unbind_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 939, "file": "drivers/char/agp/frontend.c", "instr": "memory = agp_find_mem_by_key(unbind.key);"}],
"warnings":[{"warn_data": {"at_line": 56, "warn_str": "Loop is bounded by a tainted value.", "at": "if (curr->key == key)", "inst_trace": [{"instr_func": "agpioc_unbind_wrap", "instr_loc": 936, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&unbind, arg, sizeof(struct agp_unbind)))"}, {"instr_func": "agpioc_unbind_wrap", "instr_loc": 939, "instr_file": "drivers/char/agp/frontend.c", "instr": "memory = agp_find_mem_by_key(unbind.key);"}, {"instr_func": "agpioc_unbind_wrap", "instr_loc": 939, "instr_file": "drivers/char/agp/frontend.c", "instr": "memory = agp_find_mem_by_key(unbind.key);"}, {"instr_func": "agp_find_mem_by_key", "instr_loc": 47, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_mem_by_key", "instr_loc": 56, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->key == key)"}, {"instr_func": "agp_find_mem_by_key", "instr_loc": 56, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->key == key)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_mem_by_key"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 1014, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_bind_wrap(curr_priv, (void __user *) arg);"}],
"warnings":[{"warn_data": {"at_line": 919, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&bind_info, arg, sizeof(struct agp_bind)))", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_bind_wrap"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 1014, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_bind_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 922, "file": "drivers/char/agp/frontend.c", "instr": "memory = agp_find_mem_by_key(bind_info.key);"}],
"warnings":[{"warn_data": {"at_line": 56, "warn_str": "Loop is bounded by a tainted value.", "at": "if (curr->key == key)", "inst_trace": [{"instr_func": "agpioc_bind_wrap", "instr_loc": 919, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&bind_info, arg, sizeof(struct agp_bind)))"}, {"instr_func": "agpioc_bind_wrap", "instr_loc": 922, "instr_file": "drivers/char/agp/frontend.c", "instr": "memory = agp_find_mem_by_key(bind_info.key);"}, {"instr_func": "agpioc_bind_wrap", "instr_loc": 922, "instr_file": "drivers/char/agp/frontend.c", "instr": "memory = agp_find_mem_by_key(bind_info.key);"}, {"instr_func": "agp_find_mem_by_key", "instr_loc": 47, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_mem_by_key", "instr_loc": 56, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->key == key)"}, {"instr_func": "agp_find_mem_by_key", "instr_loc": 56, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->key == key)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_mem_by_key"}, "warn_no": 1}]},
{"num_warnings": 2,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 1006, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_allocate_wrap(curr_priv, (void __user *) arg);"}],
"warnings":[{"warn_data": {"at_line": 889, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "alloc.key = memory->key;", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_allocate_wrap"}, "warn_no": 1},
{"warn_data": {"at_line": 878, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&alloc, arg, sizeof(struct agp_allocate)))", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_allocate_wrap"}, "warn_no": 2}]},
{"num_warnings": 7,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}],
"warnings":[{"warn_data": {"at_line": 804, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 1},
{"warn_data": {"at_line": 831, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}], "at_file": "drivers/char/agp/frontend.c", "by": "IntegerOverflowDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 2},
{"warn_data": {"at_line": 831, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}], "at_file": "drivers/char/agp/frontend.c", "by": "IntegerOverflowDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 3},
{"warn_data": {"at_line": 831, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}], "at_file": "drivers/char/agp/frontend.c", "by": "IntegerOverflowDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 4},
{"warn_data": {"at_line": 831, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}], "at_file": "drivers/char/agp/frontend.c", "by": "IntegerOverflowDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 5},
{"warn_data": {"at_line": 831, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 831, "instr_file": "drivers/char/agp/frontend.c", "instr": "segment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),"}], "at_file": "drivers/char/agp/frontend.c", "by": "IntegerOverflowDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 6},
{"warn_data": {"at_line": 837, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(segment, (void __user *) reserve.seg_list,", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_reserve_wrap"}, "warn_no": 7}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 810, "file": "drivers/char/agp/frontend.c", "instr": "client = agp_find_client_by_pid(reserve.pid);"}, {"lineno": 493, "file": "drivers/char/agp/frontend.c", "instr": "temp = agp_find_client_in_controller(agp_fe.current_controller, id);"}],
"warnings":[{"warn_data": {"at_line": 463, "warn_str": "Loop is bounded by a tainted value.", "at": "if (client->pid == id)", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 810, "instr_file": "drivers/char/agp/frontend.c", "instr": "client = agp_find_client_by_pid(reserve.pid);"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 810, "instr_file": "drivers/char/agp/frontend.c", "instr": "client = agp_find_client_by_pid(reserve.pid);"}, {"instr_func": "agp_find_client_by_pid", "instr_loc": 487, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_client_by_pid", "instr_loc": 493, "instr_file": "drivers/char/agp/frontend.c", "instr": "temp = agp_find_client_in_controller(agp_fe.current_controller, id);"}, {"instr_func": "agp_find_client_by_pid", "instr_loc": 493, "instr_file": "drivers/char/agp/frontend.c", "instr": "temp = agp_find_client_in_controller(agp_fe.current_controller, id);"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 454, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 463, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (client->pid == id)"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 463, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (client->pid == id)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_client_in_controller"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 852, "file": "drivers/char/agp/frontend.c", "instr": "client_priv = agp_find_private(reserve.pid);"}],
"warnings":[{"warn_data": {"at_line": 220, "warn_str": "Loop is bounded by a tainted value.", "at": "if (curr->my_pid == pid)", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 852, "instr_file": "drivers/char/agp/frontend.c", "instr": "client_priv = agp_find_private(reserve.pid);"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 852, "instr_file": "drivers/char/agp/frontend.c", "instr": "client_priv = agp_find_private(reserve.pid);"}, {"instr_func": "agp_find_private", "instr_loc": 214, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_private", "instr_loc": 220, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->my_pid == pid)"}, {"instr_func": "agp_find_private", "instr_loc": 220, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->my_pid == pid)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_private"}, "warn_no": 1}]},
{"num_warnings": 4,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 859, "file": "drivers/char/agp/frontend.c", "instr": "return agp_create_segment(client, &reserve);"}],
"warnings":[{"warn_data": {"at_line": 178, "warn_str": "Trying to read from a user pointer.", "at": "seg[i].pg_count = user_seg[i].pg_count;", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 174, "instr_file": "drivers/char/agp/frontend.c", "instr": "user_seg = region->seg_list;"}, {"instr_func": "agp_create_segment", "instr_loc": 174, "instr_file": "drivers/char/agp/frontend.c", "instr": "user_seg = region->seg_list;"}, {"instr_func": "agp_create_segment", "instr_loc": 178, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].pg_count = user_seg[i].pg_count;"}, {"instr_func": "agp_create_segment", "instr_loc": 178, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].pg_count = user_seg[i].pg_count;"}, {"instr_func": "agp_create_segment", "instr_loc": 178, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].pg_count = user_seg[i].pg_count;"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedPointerDereferenceChecker says:", "at_func": "agp_create_segment"}, "warn_no": 1},
{"warn_data": {"at_line": 177, "warn_str": "Trying to read from a user pointer.", "at": "seg[i].pg_start = user_seg[i].pg_start;", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 174, "instr_file": "drivers/char/agp/frontend.c", "instr": "user_seg = region->seg_list;"}, {"instr_func": "agp_create_segment", "instr_loc": 174, "instr_file": "drivers/char/agp/frontend.c", "instr": "user_seg = region->seg_list;"}, {"instr_func": "agp_create_segment", "instr_loc": 177, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].pg_start = user_seg[i].pg_start;"}, {"instr_func": "agp_create_segment", "instr_loc": 177, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].pg_start = user_seg[i].pg_start;"}, {"instr_func": "agp_create_segment", "instr_loc": 177, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].pg_start = user_seg[i].pg_start;"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedPointerDereferenceChecker says:", "at_func": "agp_create_segment"}, "warn_no": 2},
{"warn_data": {"at_line": 179, "warn_str": "Trying to read from a user pointer.", "at": "seg[i].prot = agp_convert_mmap_flags(user_seg[i].prot);", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 174, "instr_file": "drivers/char/agp/frontend.c", "instr": "user_seg = region->seg_list;"}, {"instr_func": "agp_create_segment", "instr_loc": 174, "instr_file": "drivers/char/agp/frontend.c", "instr": "user_seg = region->seg_list;"}, {"instr_func": "agp_create_segment", "instr_loc": 179, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].prot = agp_convert_mmap_flags(user_seg[i].prot);"}, {"instr_func": "agp_create_segment", "instr_loc": 179, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].prot = agp_convert_mmap_flags(user_seg[i].prot);"}, {"instr_func": "agp_create_segment", "instr_loc": 179, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg[i].prot = agp_convert_mmap_flags(user_seg[i].prot);"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedPointerDereferenceChecker says:", "at_func": "agp_create_segment"}, "warn_no": 3},
{"warn_data": {"at_line": 176, "warn_str": "Loop is bounded by a tainted value.", "at": "for (i = 0; i < region->seg_count; i++) {", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 176, "instr_file": "drivers/char/agp/frontend.c", "instr": "for (i = 0; i < region->seg_count; i++) {"}, {"instr_func": "agp_create_segment", "instr_loc": 176, "instr_file": "drivers/char/agp/frontend.c", "instr": "for (i = 0; i < region->seg_count; i++) {"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_create_segment"}, "warn_no": 4}]},
{"num_warnings": 5,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 859, "file": "drivers/char/agp/frontend.c", "instr": "return agp_create_segment(client, &reserve);"}, {"lineno": 168, "file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}],
"warnings":[{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %69 = add i64 %68, -1, !dbg !5498", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !5468"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !5477"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !5479"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %68 = load i64, i64* %10, align 8, !dbg !5498"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc"}, "warn_no": 1},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %44 = sub i64 %43, 1, !dbg !5494", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !5468"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !5477"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !5479"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %43 = load i64, i64* %10, align 8, !dbg !5494"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc"}, "warn_no": 2},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %61 = sub i64 %60, 1, !dbg !5494", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !5468"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !5477"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !5479"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %60 = load i64, i64* %10, align 8, !dbg !5494"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc"}, "warn_no": 3},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %53 = sub i64 %52, 1, !dbg !5494", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !5468"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !5477"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !5479"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %52 = load i64, i64* %10, align 8, !dbg !5494"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc"}, "warn_no": 4},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %48 = sub i64 %47, 1, !dbg !5494", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "agp_create_segment", "instr_loc": 168, "instr_file": "drivers/char/agp/frontend.c", "instr": "seg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !5468"}, {"instr_func": "kzalloc", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !5477"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !5479"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %47 = load i64, i64* %10, align 8, !dbg !5494"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc"}, "warn_no": 5}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 814, "file": "drivers/char/agp/frontend.c", "instr": "client_priv = agp_find_private(reserve.pid);"}],
"warnings":[{"warn_data": {"at_line": 220, "warn_str": "Loop is bounded by a tainted value.", "at": "if (curr->my_pid == pid)", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 814, "instr_file": "drivers/char/agp/frontend.c", "instr": "client_priv = agp_find_private(reserve.pid);"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 814, "instr_file": "drivers/char/agp/frontend.c", "instr": "client_priv = agp_find_private(reserve.pid);"}, {"instr_func": "agp_find_private", "instr_loc": 214, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_private", "instr_loc": 220, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->my_pid == pid)"}, {"instr_func": "agp_find_private", "instr_loc": 220, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (curr->my_pid == pid)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_private"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 824, "file": "drivers/char/agp/frontend.c", "instr": "return agp_remove_client(reserve.pid);"}, {"lineno": 531, "file": "drivers/char/agp/frontend.c", "instr": "controller = agp_find_controller_for_client(id);"}, {"lineno": 478, "file": "drivers/char/agp/frontend.c", "instr": "if ((agp_find_client_in_controller(controller, id)) != NULL)"}],
"warnings":[{"warn_data": {"at_line": 463, "warn_str": "Loop is bounded by a tainted value.", "at": "if (client->pid == id)", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 824, "instr_file": "drivers/char/agp/frontend.c", "instr": "return agp_remove_client(reserve.pid);"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 824, "instr_file": "drivers/char/agp/frontend.c", "instr": "return agp_remove_client(reserve.pid);"}, {"instr_func": "agp_remove_client", "instr_loc": 525, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_remove_client", "instr_loc": 531, "instr_file": "drivers/char/agp/frontend.c", "instr": "controller = agp_find_controller_for_client(id);"}, {"instr_func": "agp_remove_client", "instr_loc": 531, "instr_file": "drivers/char/agp/frontend.c", "instr": "controller = agp_find_controller_for_client(id);"}, {"instr_func": "agp_find_controller_for_client", "instr_loc": 472, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_controller_for_client", "instr_loc": 478, "instr_file": "drivers/char/agp/frontend.c", "instr": "if ((agp_find_client_in_controller(controller, id)) != NULL)"}, {"instr_func": "agp_find_controller_for_client", "instr_loc": 478, "instr_file": "drivers/char/agp/frontend.c", "instr": "if ((agp_find_client_in_controller(controller, id)) != NULL)"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 454, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 463, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (client->pid == id)"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 463, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (client->pid == id)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_client_in_controller"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 998, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);"}, {"lineno": 824, "file": "drivers/char/agp/frontend.c", "instr": "return agp_remove_client(reserve.pid);"}, {"lineno": 535, "file": "drivers/char/agp/frontend.c", "instr": "client = agp_find_client_in_controller(controller, id);"}],
"warnings":[{"warn_data": {"at_line": 463, "warn_str": "Loop is bounded by a tainted value.", "at": "if (client->pid == id)", "inst_trace": [{"instr_func": "agpioc_reserve_wrap", "instr_loc": 804, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 824, "instr_file": "drivers/char/agp/frontend.c", "instr": "return agp_remove_client(reserve.pid);"}, {"instr_func": "agpioc_reserve_wrap", "instr_loc": 824, "instr_file": "drivers/char/agp/frontend.c", "instr": "return agp_remove_client(reserve.pid);"}, {"instr_func": "agp_remove_client", "instr_loc": 525, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_remove_client", "instr_loc": 535, "instr_file": "drivers/char/agp/frontend.c", "instr": "client = agp_find_client_in_controller(controller, id);"}, {"instr_func": "agp_remove_client", "instr_loc": 535, "instr_file": "drivers/char/agp/frontend.c", "instr": "client = agp_find_client_in_controller(controller, id);"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 454, "instr_file": "drivers/char/agp/frontend.c", "instr": "{"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 463, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (client->pid == id)"}, {"instr_func": "agp_find_client_in_controller", "instr_loc": 463, "instr_file": "drivers/char/agp/frontend.c", "instr": "if (client->pid == id)"}], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedLoopBoundDetector says:", "at_func": "agp_find_client_in_controller"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 994, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_setup_wrap(curr_priv, (void __user *) arg);"}],
"warnings":[{"warn_data": {"at_line": 790, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&mode, arg, sizeof(struct agp_setup)))", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_setup_wrap"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca %struct.file*, align 8"}, {"lineno": 982, "file": "drivers/char/agp/frontend.c", "instr": "ret_val = agpioc_info_wrap(curr_priv, (void __user *) arg);"}],
"warnings":[{"warn_data": {"at_line": 722, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "(kerninfo.device->device << 16);", "inst_trace": [], "at_file": "drivers/char/agp/frontend.c", "by": "TaintedSizeDetector says:", "at_func": "agpioc_info_wrap"}, "warn_no": 1}]}]}