{"all_contexts":[
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}],
"warnings":[{"warn_data": {"at_line": 817, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&options, (u64 __user *)arg, sizeof(u64)))", "inst_trace": [], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedSizeDetector says:", "at_func": "stm_char_ioctl"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 814, "file": "drivers/hwtracing/stm/core.c", "instr": "return stm_char_policy_get_ioctl(stmf, (void __user *)arg);"}],
"warnings":[{"warn_data": {"at_line": 784, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "{", "inst_trace": [], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedSizeDetector says:", "at_func": "stm_char_policy_get_ioctl"}, "warn_no": 1}]},
{"num_warnings": 3,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 807, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}],
"warnings":[{"warn_data": {"at_line": 746, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "id = kzalloc(size + 1, GFP_KERNEL);", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 736, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(&size, arg, sizeof(size)))"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "stm_char_policy_set_ioctl"}, "warn_no": 1},
{"warn_data": {"at_line": 736, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(&size, arg, sizeof(size)))", "inst_trace": [], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedSizeDetector says:", "at_func": "stm_char_policy_set_ioctl"}, "warn_no": 2},
{"warn_data": {"at_line": 750, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "if (copy_from_user(id, arg, size)) {", "inst_trace": [], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedSizeDetector says:", "at_func": "stm_char_policy_set_ioctl"}, "warn_no": 3}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 811, "file": "drivers/hwtracing/stm/core.c", "instr": "return stm_char_policy_get_ioctl(stmf, (void __user *)arg);"}],
"warnings":[{"warn_data": {"at_line": 784, "warn_str": "Non-constant size used in copy_to(or from)_user function.", "at": "{", "inst_trace": [], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedSizeDetector says:", "at_func": "stm_char_policy_get_ioctl"}, "warn_no": 1}]},
{"num_warnings": 6,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 807, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"lineno": 746, "file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}],
"warnings":[{"warn_data": {"at_line": 557, "warn_str": "Trying to use a global variable without locking.", "at": "  %234 = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %233, !dbg !24628", "inst_trace": [{"instr_func": "stm_char_ioctl", "instr_loc": -1, "instr": "  %4 = alloca i8*, align 8"}, {"instr_func": "stm_char_ioctl", "instr_loc": 807, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}], "at_file": "./include/linux/slab.h", "by": "GlobalVariableRaceDetector says:", "at_func": "kzalloc.31"}, "warn_no": 1},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %69 = add i64 %68, -1, !dbg !24440", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 736, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(&size, arg, sizeof(size)))"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !24410"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !24419"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !24421"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %68 = load i64, i64* %10, align 8, !dbg !24440"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc.31"}, "warn_no": 2},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %44 = sub i64 %43, 1, !dbg !24436", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 736, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(&size, arg, sizeof(size)))"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !24410"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !24419"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !24421"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %43 = load i64, i64* %10, align 8, !dbg !24436"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc.31"}, "warn_no": 3},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %61 = sub i64 %60, 1, !dbg !24436", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 736, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(&size, arg, sizeof(size)))"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !24410"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !24419"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !24421"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %60 = load i64, i64* %10, align 8, !dbg !24436"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc.31"}, "warn_no": 4},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %53 = sub i64 %52, 1, !dbg !24436", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 736, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(&size, arg, sizeof(size)))"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !24410"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !24419"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !24421"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %52 = load i64, i64* %10, align 8, !dbg !24436"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc.31"}, "warn_no": 5},
{"warn_data": {"at_line": 549, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "  %48 = sub i64 %47, 1, !dbg !24436", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 736, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(&size, arg, sizeof(size)))"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 746, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id = kzalloc(size + 1, GFP_KERNEL);"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %0, i64* %18, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 686, "instr_file": "./include/linux/slab.h", "instr": "  %20 = load i64, i64* %18, align 8, !dbg !24410"}, {"instr_func": "kzalloc.31", "instr_loc": 685, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %20, i64* %15, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %29 = load i64, i64* %15, align 8, !dbg !24419"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %29, i64* %11, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 484, "instr_file": "./include/linux/slab.h", "instr": "  %31 = load i64, i64* %11, align 8, !dbg !24421"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  store i64 %31, i64* %10, align 8"}, {"instr_func": "kzalloc.31", "instr_loc": 549, "instr_file": "./include/linux/slab.h", "instr": "  %47 = load i64, i64* %10, align 8, !dbg !24436"}], "at_file": "./include/linux/slab.h", "by": "IntegerOverflowDetector says:", "at_func": "kzalloc.31"}, "warn_no": 6}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 807, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"lineno": 765, "file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"lineno": 560, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"lineno": 307, "file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}],
"warnings":[{"warn_data": {"at_line": 270, "warn_str": "Loop is bounded by a tainted value.", "at": "if (pos < 0)", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}, {"instr_func": "find_free_channels", "instr_loc": 238, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "return pos;"}, {"instr_func": "find_free_channels", "instr_loc": 238, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "return pos;"}, {"instr_func": "find_free_channels", "instr_loc": 245, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "}"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "stm_find_master_chan", "instr_loc": 270, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos < 0)"}, {"instr_func": "stm_find_master_chan", "instr_loc": 270, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos < 0)"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedLoopBoundDetector says:", "at_func": "stm_find_master_chan"}, "warn_no": 1}]},
{"num_warnings": 10,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 807, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"lineno": 765, "file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"lineno": 560, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"lineno": 307, "file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"lineno": 268, "file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}],
"warnings":[{"warn_data": {"at_line": 237, "warn_str": "Loop is bounded by a tainted value.", "at": "if (i == width)", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 237, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (i == width)"}, {"instr_func": "find_free_channels", "instr_loc": 237, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (i == width)"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedLoopBoundDetector says:", "at_func": "find_free_channels"}, "warn_no": 1},
{"warn_data": {"at_line": 227, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 2},
{"warn_data": {"at_line": 227, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 3},
{"warn_data": {"at_line": 227, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 4},
{"warn_data": {"at_line": 232, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "if (pos & (width - 1))", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 232, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos & (width - 1))"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 5},
{"warn_data": {"at_line": 229, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "if (pos + width > end + 1)", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 229, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos + width > end + 1)"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 6},
{"warn_data": {"at_line": 229, "warn_str": "Loop is bounded by a tainted value.", "at": "if (pos + width > end + 1)", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 229, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos + width > end + 1)"}, {"instr_func": "find_free_channels", "instr_loc": 229, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos + width > end + 1)"}, {"instr_func": "find_free_channels", "instr_loc": 229, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (pos + width > end + 1)"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedLoopBoundDetector says:", "at_func": "find_free_channels"}, "warn_no": 7},
{"warn_data": {"at_line": 227, "warn_str": "Loop is bounded by a tainted value.", "at": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "TaintedLoopBoundDetector says:", "at_func": "find_free_channels"}, "warn_no": 8},
{"warn_data": {"at_line": 241, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "pos += i;", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 241, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos += i;"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 9},
{"warn_data": {"at_line": 235, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "for (i = 1; i < width && !test_bit(pos + i, bitmap); i++)", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_output_assign", "instr_loc": 307, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_find_master_chan(stm, width, &midx, mend, &cidx, cend);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 251, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_find_master_chan", "instr_loc": 269, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "width);"}, {"instr_func": "stm_find_master_chan", "instr_loc": 268, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "pos = find_free_channels(master->chan_map, *cstart, cend,"}, {"instr_func": "find_free_channels", "instr_loc": 223, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 227, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (pos = start; pos < end + 1; pos = ALIGN(pos, width)) {"}, {"instr_func": "find_free_channels", "instr_loc": 235, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "for (i = 1; i < width && !test_bit(pos + i, bitmap); i++)"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "find_free_channels"}, "warn_no": 10}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 807, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"lineno": 765, "file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"lineno": 560, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"lineno": 326, "file": "drivers/hwtracing/stm/core.c", "instr": "stm_output_claim(stm, output);"}],
"warnings":[{"warn_data": {"at_line": 199, "warn_str": "Potential overflow, using tainted value in binary operation.", "at": "master->nr_free -= output->nr_chans;", "inst_trace": [{"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 750, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "if (copy_from_user(id, arg, size)) {"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 766, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "id->width);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 544, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 560, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_output_assign(stm, width, pn, output);"}, {"instr_func": "stm_output_assign", "instr_loc": 284, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "{"}, {"instr_func": "stm_output_assign", "instr_loc": 313, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "output->nr_chans = width;"}, {"instr_func": "stm_output_assign", "instr_loc": 313, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "output->nr_chans = width;"}, {"instr_func": "stm_output_claim", "instr_loc": 199, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "master->nr_free -= output->nr_chans;"}], "at_file": "drivers/hwtracing/stm/core.c", "by": "IntegerOverflowDetector says:", "at_func": "stm_output_claim"}, "warn_no": 1}]},
{"num_warnings": 1,
"context":[{"lineno": -1, "instr": "  %4 = alloca i8*, align 8"}, {"lineno": 807, "file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"lineno": 765, "file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"lineno": 562, "file": "drivers/hwtracing/stm/core.c", "instr": "stp_policy_node_put(pn);"}],
"warnings":[{"warn_data": {"at_line": 554, "warn_str": "Trying to use a global variable without locking.", "at": "lockdep_assert_held(&stp_policy_subsys.su_mutex);", "inst_trace": [{"instr_func": "stm_char_ioctl", "instr_loc": -1, "instr": "  %4 = alloca i8*, align 8"}, {"instr_func": "stm_char_ioctl", "instr_loc": 807, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "err = stm_char_policy_set_ioctl(stmf, (void __user *)arg);"}, {"instr_func": "stm_char_policy_set_ioctl", "instr_loc": 765, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "ret = stm_assign_first_policy(stmf->stm, &stmf->output, ids,"}, {"instr_func": "stm_assign_first_policy", "instr_loc": 562, "instr_file": "drivers/hwtracing/stm/core.c", "instr": "stp_policy_node_put(pn);"}], "at_file": "drivers/hwtracing/stm/policy.c", "by": "GlobalVariableRaceDetector says:", "at_func": "stp_policy_node_put"}, "warn_no": 1}]}]}